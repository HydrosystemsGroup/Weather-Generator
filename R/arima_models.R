#' Create arima models of wavelet components
#'
#' @param components 2-d numeric array of wavelet components generated by wavelet_components
#' @export
#' @examples
#' arima_models(cbind("COMPONENT"=sin(1:50) + rnorm(50) + 10, "NOISE"=rnorm(50)))
arima_models <- function(components) {
  apply(components, 2, forecast::auto.arima, max.p=2, max.q=2,
                                             max.P=0, max.Q=0,
                                             stationary=TRUE)
}

#' Run simulation of an arima model
#'
#' @param model arima model object
#' @param n number of simulation timesteps
#' @export
#' @examples
#' library(forecast)
#' model <- auto.arima(sin(1:50)+rnorm(50)+10, max.p=2, max.q=2, max.P=0, max.Q=0, stationary=TRUE)
#' simulate_arima(model, n=40)

simulate_arima <- function(model, n) {
  sim <- arima.sim(n=n,
                   list(ar=coef(model)[grepl('ar', names(coef(model)))],
                        ma=coef(model)[grepl('ma', names(coef(model)))]),
                   sd = sqrt(model$sigma2[[1]]))

  # extract intercept
  if ('intercept' %in% names(model$coef)) {
    intercept <- model$coef['intercept']
  } else {
    intercept <- 0
  }

  # add intercept (mean) to current simulation
  sim <- sim + intercept

  return(zoo::coredata(sim))
}

#' Run simulations of multiple arima models
#'
#' @param models list of arima model objects (e.g. noise and wavelet components)
#' @param n number of simulation timesteps
#' @param components if TRUE returns list containing both the sum and indidividual components, otherwise returns just sum vector
#' @export
#' @examples
#' library(forecast)
#' models <- list(COMPONENT=auto.arima(sin(1:50)+rnorm(50)+10, max.p=2, max.q=2, max.P=0, max.Q=0, stationary=TRUE),
#'                NOISE=auto.arima(rnorm(50), max.p=2, max.q=2, max.P=0, max.Q=0, stationary=TRUE))
#' simulate_arimas(models, n=40)
simulate_arimas <- function(models, n, components=TRUE) {
  # run simulation on each model and combine into 2-d array
  sim.components <- lapply(models, simulate_arima, n=n)
  sim.components <- sapply(sim.components, cbind)

  # compute sum of individual component simulations
  if (ncol(sim.components) > 1) {
    sim.sum <- apply(sim.components, 1, FUN=sum)
  } else {
    sim.sum <- sim.components
  }

  if (components) {
    return(list(components=sim.components, sum=sim.sum))
  } else {
    return(sim.sum)
  }
}

#' Run Monte Carlo simulation of arima models
#'
#' @param models list of arima model objects (e.g. noise and wavelet components)
#' @param n number of simulation timesteps
#' @param n.iter number of monte carlo iterations
#' @export
#' @examples
#' library(forecast)
#' models <- list(COMPONENT=auto.arima(sin(1:50)+rnorm(50)+10, max.p=2, max.q=2, max.P=0, max.Q=0, stationary=TRUE),
#'                NOISE=auto.arima(rnorm(50), max.p=2, max.q=2, max.P=0, max.Q=0, stationary=TRUE))
#' mc_arimas(models, n=40, n.iter=100)
mc_arimas <- function(models, n, n.iter) {
  # run dummy simulation and wavelet analysis to get number of periods for wavelet transform
  temp.sim.warm <- simulate_arimas(models=models, n=n)
  temp.wt <- wavelet_analysis(temp.sim.warm$sum, sig.level=0.90, noise.type='white')

  sim.x <- array(NA, c(n, n.iter))
  sim.gws <- array(NA, c(length(temp.wt$gws), n.iter))
  for (i in 1:n.iter) {
    i.sim.warm <- simulate_arimas(models=models, n=n)
    i.wt <- wavelet_analysis(i.sim.warm$sum, sig.level=0.90, noise.type='white')
    sim.x[,i] <- i.sim.warm$sum
    sim.gws[,i] <- i.wt$gws
  }

  sim.x.stat <- cbind(MEAN=rowMeans(sim.x),
                      Q025=apply(sim.x, 1, quantile, 0.025),
                      Q975=apply(sim.x, 1, quantile, 0.975))

  sim.gws.stat <- cbind(MEAN=rowMeans(sim.gws),
                        Q025=apply(sim.gws, 1, quantile, 0.025),
                        Q975=apply(sim.gws, 1, quantile, 0.975))

  return(list(x=sim.x, gws=sim.gws, x.stat=sim.x.stat, gws.stat=sim.gws.stat))
}