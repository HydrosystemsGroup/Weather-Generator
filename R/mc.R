#' Run Markov Chain Simulation
#'
#' @param months numeric array of months for each daily time step
#' @param initial initial state
#' @param states character vector of markov states
#' @param transitions monthly list of transition matrices generated by mc_fit()
#' @export
#' @examples
#' transitions <- mc_fit(x=sample(c('d', 'w', 'e'), size=720, replace=TRUE, prob=c(0.5, 0.3, 0.2)), months=rep(rep(seq(1, 12), each=30), times=2))
#' mc_sim(months=rep(1:12, each=30), initial='d', states=c('d', 'w', 'e'), transitions=transitions)
#'
mc_sim <- function(months, initial, states, transitions) {
  n <- length(months)

  chain <- rep(NA_character_, times=n)
  chain[1] <- initial

  for (i in 2:n) {
    chain[i] <- sample(states, size=1, prob=transitions[[months[i-1]]][chain[i-1], ])
  }

  chain <- ordered(chain, levels=states)

  chain
}

#' Fit Markov Chain Transition Matrices to State Sequence
#'
#' @param states character array of states as ordered factor
#' @param months numeric array of months for each daily time step
#' @export
#' @examples
#' transitions <- mc_fit(x=sample(c('d', 'w', 'e'), size=720, replace=TRUE, prob=c(0.5, 0.3, 0.2)), months=rep(rep(seq(1, 12), each=30), times=2))
#'
mc_fit <- function(states, months) {
  stopifnot(length(states) == length(months))

  states_next <- lead(states)
  transitions <- lapply(seq(1, 12), function(m) {
    idx <- which(months==m)
    prop.table(table(states[idx], states_next[idx]), 1)
  })
  transitions
}


#' Determine Markov State Thresholds from Precipitation
#'
#' @param prcp vector of daily precipitation
#' @param months vector of months corresponding to daily precipitation
#' @param dry_wet threshold precipitation amount for dry/wet states
#' @param wet_extreme_quantile threshold quantile for wet/extreme states
#' @export
mc_state_threshold <- function(prcp, months, dry_wet=0.3, wet_extreme_quantile=0.8) {
  stopifnot(any(!is.na(prcp)))
  stopifnot(any(!is.na(months)))
  stopifnot(length(prcp) == length(months))

  df <- data.frame(MONTH=months, PRCP=prcp)

  thresh <- plyr::dlply(df, c("MONTH"), function(x) {
    c(dry_wet, unname(quantile(x[['PRCP']], probs=wet_extreme_quantile)))
  })

  thresh
}

#' Assign Markov States from Precipitation and State Thresholds
#'
#' @param prcp vector of daily precipitation
#' @param months vector of months corresponding to daily precipitation
#' @param states character list of markov states
#' @param thresholds list of monthly transition matrices generated from mc_fit()
#' @export
mc_assign_states <- function(prcp, months, states, thresholds) {
  stopifnot(length(prcp)==length(months))
  stopifnot(length(thresholds)==12)

  x <- data.frame(PRCP=prcp, MONTH=months)
  x <- group_by(x, MONTH)
  x <- mutate(x, STATE=cut(PRCP, breaks=c(0, thresholds[[unique(MONTH)]], Inf), include.lowest=TRUE, right=TRUE, labels=states))
  x <- ungroup(x)
  x[['STATE']] <- ordered(x[['STATE']], levels=states)
  x[['STATE']]
}

#' Adjust Markov Chain Transition Matrix
#'
#' @param transition markov transition matrix
#' @param dry_spell change factor for dry spell (default=1, no change)
#' @param wet_spell change factor for wet spell (default=1, no change)
#' @export
#' @examples
#' transitions <- mc_fit(x=sample(c('d', 'w', 'e'), size=720, replace=TRUE, prob=c(0.5, 0.3, 0.2)), months=rep(rep(seq(1, 12), each=30), times=2))
#' mc_sim(months=rep(1:12, each=30), initial='d', states=c('d', 'w', 'e'), transitions=transitions)
#'
mc_adjust_transition <- function(transition, dry_spell=1, wet_spell=1) {
  states <- rownames(transition)

  p <- transition
  p_new <- p

  # adjust dry spell
  p_dw <- (p[states[1], states[2]] + p[states[1], states[3]])/dry_spell - p[states[1], states[3]]
  p_dd <- p[states[1], states[1]] + (p[states[1], states[2]] - p_dw)
  p_new[states[1],states[2]] <- p_dw
  p_new[states[1],states[1]] <- p_dd

  #adjust wet spell
  p_wd <- (p[states[2], states[1]] + p[states[2], states[3]])/wet_spell - p[states[2], states[3]]
  p_ww <- p[states[2], states[2]] + (p[states[2], states[1]] - p_wd)
  p_new[states[2],states[1]] <- p_wd
  p_new[states[2],states[2]] <- p_ww

  stopifnot(all(p_new > 0))

  p_new
}

#' Compute Equilibrium Vector of Transition Matrix
#'
#' @param m markov transition matrix
#' @export
#' @examples
#' transitions <- mc_fit(x=sample(c('d', 'w', 'e'), size=720, replace=TRUE, prob=c(0.5, 0.3, 0.2)), months=rep(rep(seq(1, 12), each=30), times=2))
#' mc_equilibrium(transitions[[1]])
#'
mc_equilibrium <- function(m) {
  eig <- eigen(t(m))$vectors[,1]
  eig <- eig/sum(eig)
  names(eig) <- rownames(m)
  eig
}
